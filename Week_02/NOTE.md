一、HashMap的结构
     Map集合即Key-Value的集合，前面加个Hash，即散列，无序的。所以HashMap是一个用于存储Key-Value键值对的无序集合，每一个键值对也叫做Entry。

     在JDK1.8之前，HashMap采用数组+链表实现，即使用链表处理冲突，同一hash值的节点都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值查找要遍历链表，时间复杂度为O(N)，效率较低。因此JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，时间复杂度为O(logN)，这样大大减少了查找时间。
 1，链表
    Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。
    
2，
HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。
 HashMap的基本数据结构是数组加链表的。HashMap数组的每一个元素不止是一个Entry对象，也是一个链表的头节点。每一个Entry对象通过Next指针指向它的下一个Entry节点。当新来的Entry映射到冲突的数组位置时，只需要插入到对应的链表尾部即可。当链表长度大于8时，链表转为红黑树，以此提高查找效率。 HashMap数组每一个元素的初始值都是Null。
 
 二,put流程
 1. 根据key计算得到key.hash = (h = k.hashCode()) ^ (h >>> 16)；

2. 根据key.hash计算得到桶数组的索引index = key.hash & (table.length - 1)，这样就找到该key的存放位置了：

① 如果该位置没有数据，用该数据新生成一个节点保存新数据，返回null；

② 如果该位置有数据是一个红黑树，那么执行相应的插入 / 更新操作；

③ 如果该位置有数据是一个链表，分两种情况一是该链表没有这个节点，另一个是该链表上有这个节点，注意这里判断的依据是key.hash是否一样：

如果该链表没有这个节点，那么采用尾插法新增节点保存新数据，返回null；如果该链表已经有这个节点了，那么找到该节点并更新新数据，返回老数据。

3. 如果是链表，加入新节点以后长度>=8，转为红黑树。

   如果hashMap的实际节点数>容量*负载因子，扩容。
